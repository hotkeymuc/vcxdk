#!/usr/bin/python3
# -*- coding: utf-8 -*-
"""
LLVM-IR to CR16B-Assembly compiler
==================================

There is no open source version of a CR16B compiler, yet. (There is only the proprietary CR16 Toolset for Windows)

Idea:
	* Let a known compiler produce LLVM IR code (e.g. clang)
		clang -S -emit-llvm foo.c
		clang -cc1 foo.c -emit-llvm
	* Transform LLVM IR instructions into CR16B assembly
	* Compile/link using cr16b_asm.py


2022-05-15 Bernhard "HotKey" Slawik
"""
import os
from collections import OrderedDict	# To keep the order when parsing function arguments
import datetime

def put(t):
	print(t)
def put_debug(t):
	print(t)

def parse_type(type_text):
	r = type_text
	return r

def parse_params_text(params_text):
	words = params_text.split(',')
	r = OrderedDict()
	for w in words:
		w = w.strip()
		if w == '': continue
		ws = w.split(' ')
		type_text = ' '.join(ws[:-1])
		name = ws[-1]
		r[name] = parse_type(type_text)
	return r


class CR16B_LLVM_IR_Compiler:
	def __init__(self):
		self.lines = []
		self.line_num = -1
	
	def put(self, text):
		put(text)
	def put_debug(self, text):
		put_debug(text)
	
	def compile(self, filename_c):
		filename_base = filename_c[:filename_c.rindex('.')]
		filename_ll = '%s.ll' % filename_base
		filename_asm = '%s.s' % filename_base
		
		self.compile_c_to_llvm(filename_c)
		
		self.compile_llvm_to_asm(filename_ll, filename_asm)
		
	
	def compile_c_to_llvm(self, filename_c):
		filename_ll = filename_c[:filename_c.rindex('.')] + '.ll'
		
		# Clean
		if os.path.isfile(filename_ll):
			self.put('Cleaning LLVM file "%s"...' % filename_ll)
			os.remove(filename_ll)
		
		self.put('Compiling "%s" to LLVM "%s"...' % (filename_c, filename_ll))
		r = os.system('clang -S -emit-llvm %s' % filename_c)
		#put('clang result=%s' % str(r))
		
		if r != 0:
			raise Exception('Compilation using clang failed. r=%s' % str(r))
		
		if not os.path.isfile(filename_ll):
			raise ParseErrror('LLVM file "%s" was not created!' % filename_ll)
		
	
	def compile_llvm_to_asm(self, filename_ll, filename_asm):
		self.put('Loading LLVM file "%s"...' % filename_ll)
		with open(filename_ll, 'r') as h:
			data = h.read()
		
		self.put('Translating to ASM file "%s"...' % filename_asm)
		with open(filename_asm, 'w') as h:
			self.emit_handle = h
			
			self.emit('; Original LLVM IR file: "%s"' % filename_ll)
			self.emit('; Auto-generated by "%s" at %s\n' % (__file__, datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
			
			self.lines = data.split('\n')
			self.line_num = -1
			self.parse_root()
		
	
	def emit(self, t):
		put('>>> %s' % str(t))
		
		if self.emit_handle is not None:
			self.emit_handle.write('%s\n' % t)
	
	def get_next_line(self, strip=True):
		self.line_num += 1
		if self.line_num >= len(self.lines):
			self.put('End of file!')
			return None
		line = self.lines[self.line_num]
		
		#self.put('%d:	%s' % (self.line_num, line))
		
		if strip:
			# Strip comments
			if ';' in line: line = line[:line.index(';')]
			
			# Compress
			line = line.strip()
		
		return line
	
	def parse_root(self):
		while True:
			line = self.get_next_line()
			line_i = self.line_num
			if line is None: break
			if line == '': continue
			
			words = line.split(' ')
			# Early ignore of some meta stuff
			if words[0] == 'source_filename': continue
			if words[0] == 'target': continue
			
			#self.put_debug('parse_root: %s' % line)
			
			if words[0] == 'define':
				ret_type_text = words[2]
				ret_type = parse_type(ret_type_text)
				rest_text = ' '.join(words[3:])
				
				name = rest_text[:rest_text.index('(')]
				#name = '_function_%s' % (name.replace('%', ''))
				if name.startswith('@'):
					name = name[1:]
				
				params_text = rest_text[rest_text.index('(')+1:rest_text.index(')')]
				params_texts = parse_params_text(params_text)
				params = OrderedDict()
				for i, param_id in enumerate(params_texts.keys()):
					params[param_id] = {
						'id': param_id,
						'register': 'r%d' % (2+i),
						'first_read': None,
						'last_read': None,
						'first_write': line_i,
						'last_write': line_i,
						'text': params_texts[param_id],
					}
				self.parse_block(def_name=name, params=params)
			
		
	def parse_block(self, def_name, params):
		"""Parse LLVM IR code block (i.e. a function)"""
		
		# New function "define dso_local void @put(i8* %0) #0 {"
		self.put('Parsing block "%s"...' % def_name)
		
		params_count = len(params)
		start_line_num = self.line_num
		
		self.emit('; Function "%s"' % def_name)
		self.emit('; Uses %d parameter(s):' % params_count)
		for id, param in params.items():
			self.emit(';	* %s in %s' % (param['id'], param['register']))
		
		
		# State
		assignments = params
		labels = {}
		loop_labels = {}	# List of labels that are jumped BACK to
		heap_size = 0
		register_use = {}
		for i in range(14):
			reg_name = 'r%d' % i
			register_use[reg_name] = False
		
		# Parameters are blocking r2...
		for i in range(params_count):
			reg_name = 'r%d' % (2+i)
			register_use[reg_name] = True
		# r0 is our scratch register and should never be free to use
		register_use['r0'] = True
		
		
		### Step 1: Pre-process, count number of assignments
		while True:
			line = self.get_next_line()
			line_i = self.line_num
			if line is None: break
			if line == '': continue
			if line == '}': break
			#self.put_debug('parse_block: pre-processing:	%d	%s' % (line_i, line))
			
			words = line.split(' ')
			
			if words[0][-1:] == ':':
				#self.put_debug('Label')
				labels[words[0][:-1]] = line_i
			
			elif (len(words) > 2) and (words[1] == '='):
				#self.put('Assignment')
				dst_name = words[0]
				
				if dst_name in assignments:
					# Known assignment
					if assignments[dst_name]['first_write'] is None:
						assignments[dst_name]['first_write'] = line_i
					assignments[dst_name]['last_write'] = line_i
				else:
					# New assignment
					
					reg = None	# register is allocated just-in-time
					type_text = ' '.join(words[2:])
					type_size = None
					
					assignments[dst_name] = {
						'id': dst_name,
						'register': reg,
						'type_text': type_text,
						'type_size': type_size,
						'first_read': None,
						'last_read': None,
						'first_write': line_i,
						'last_write': line_i,
						
					}
				
				if words[2] == 'alloca':
					#@TODO: Actually reserve some memory on heap
					#@FIXME: Think about how to actually store the data...
					#@TODO: Pad according to given "align" parameter?
					type_text = words[3].replace(',','')
					if type_text == 'i8*': type_size = 1
					elif type_text == 'i16*': type_size = 2
					elif type_text == 'i32*': type_size = 4
					elif type_text == 'i8': type_size = 1
					elif type_text == 'i16': type_size = 2
					elif type_text == 'i32': type_size = 4
					else:
						self.put('Unknown type "%s" - cannot guess size!' % type_text)
						type_size = 2
					
					# Remember an address on heap
					assignments[dst_name]['register'] = heap_size
					assignments[dst_name]['type_text'] = type_text
					assignments[dst_name]['type_size'] = type_size
					
					heap_size += type_size
					pass
					
				elif words[2] == 'load':
					addr_name = words[5].replace(',', '')
					if assignments[addr_name]['first_read'] is None:
						assignments[addr_name]['first_read'] = line_i
					assignments[addr_name]['last_read'] = line_i
				
				elif words[2] in ['icmp', 'mul', 'add']:
					a1_name = words[5].replace(',', '')
					a2_name = words[6].replace(',', '')
					
					if a1_name in assignments:
						if assignments[a1_name]['first_read'] is None:
							assignments[a1_name]['first_read'] = line_i
						assignments[a1_name]['last_read'] = line_i
					
					if a2_name in assignments:
						if assignments[a2_name]['first_read'] is None:
							assignments[a2_name]['first_read'] = line_i
						assignments[a2_name]['last_read'] = line_i
					
				else:
					
					#@TODO: Handle other operations (icmp, mul, ...)
					raise Exception('UNSUPPORTED FOR ASSIGNMENT STATISTICS, YET: %s' % line)
					
			
			elif words[0] == 'store':
				src_name = words[2].replace(',', '')
				if (src_name in assignments):
					if assignments[src_name]['first_read'] is None:
						assignments[src_name]['first_read'] = line_i
					assignments[src_name]['last_read'] = line_i
				
				dst_name = words[4].replace(',', '')
				if assignments[dst_name]['first_write'] is None:
					assignments[dst_name]['first_write'] = line_i
				assignments[dst_name]['last_write'] = line_i
				
			
			elif words[0] == 'br':
				# Check for backwards-jumps
				# We could just see if the label is yet known (part of labels[]), but it's good practice to also check if the label actually points backwards
				# Record the latest line number that jumps back to the loop_label, so we can see the whole scope of that loop
				if words[1] == 'label':
					label_name = words[2].replace('%','')
					if (label_name in labels) and (labels[label_name] < line_i):
						self.put_debug('Found backwards-jump (loop) to label "%s"' % label_name)
						if not label_name in loop_labels: loop_labels[label_name] = 0	#[]
						loop_labels[label_name] = max(loop_labels[label_name], line_i)	#.append(line_i)
					
				elif words[1] == 'i1':
					if_name = words[4].replace('%','').replace(',', '')
					else_name = words[6].replace('%','').replace(',', '')
					
					if (if_name in labels) and (labels[if_name] < line_i):
						self.put_debug('Found backwards-jump (loop) to label "%s"' % if_name)
						if not if_name in loop_labels: loop_labels[if_name] = 0	#[]
						loop_labels[if_name] = max(loop_labels[if_name], line_i)	#.append(line_i)
					if (else_name in labels) and (labels[else_name] < line_i):
						self.put_debug('Found backwards-jump (loop) to label "%s"' % else_name)
						if not else_name in loop_labels: loop_labels[else_name] = 0	#[]
						loop_labels[else_name] = max(loop_labels[else_name], line_i)	#.append(line_i)
				else:
					raise Exception('Unknown branching condition in "%s"' % line)
			
			elif words[0] == 'call':
				rest_text = ' '.join(words[2:])
				
				call_name = rest_text[:rest_text.index('(')]
				args_text = rest_text[rest_text.index('(')+1:rest_text.rindex(')')]
				#args = parse_params_text(args_text)
				
				#@TODO: Parse call arguments!
				
				self.put('@TODO: Analyze args of call "%s" to determine register use (last_read):"%s"' % (call_name, args_text))
				# Update use of parameters
				# Maybe even pre-select registers?
				#@FIXME: This is sooooo dirty! Argh!
				#@TODO: Return value?
				#@TODO: passed-as-reference are written to!
				for a_id, assignment in assignments.items():
					if (a_id+',' in args_text) or (a_id+')' in args_text+')'):
						if assignment['first_read'] is None:
							assignment['first_read'] = line_i
						assignment['last_read'] = line_i
			
			#else:
			#	self.put('Unhandled: %s' % line)
		
		#put('Assignments found: %s' % str(assignments))
		self.put('Assignments:')
		a_ids = []
		for a_id, assignment in assignments.items():
			a_ids.append(a_id)
			self.put('	* %s: %s' % (a_id, str(assignment)))
		
		
		self.emit('; Uses %d local assignment(s) excl. params' % (len(assignments) - params_count))
		self.emit('; Uses %d byte(s) of heap' % heap_size)
		
		
		# Emit function preamble
		self.emit('_%s:' % def_name)
		
		#self.emit('push    $2, era\n')
		
		# Make space on stack
		#self.emit('	addw	$-%d,sp' % ((len(assignments) - params_count) * 2))
		self.emit('	addw	$-%d,sp' % heap_size)
		
		# Copy parameters to local assignments
		#for i in range(params_count):
		#	self.emit('	storw	r%d,0(sp)' % (2+i))
		
		
		### Step 2: Parse instructions
		self.line_num = start_line_num
		line_i = self.line_num
		while True:
			# Check if we can free some registers
			for a_id, assignment in assignments.items():
				last_use = None
				if (assignment['last_write'] is not None):
					last_use = assignment['last_write']
				if (assignment['last_read'] is not None):
					if last_use is None:
						last_use = assignment['last_read']
					else:
						last_use = max(last_use, assignment['last_read'])
				if last_use == line_i:
					reg_name = assignment['register']
					#self.put_debug('Can free up %s (%s)' % (a_id, reg_name)))
					if reg_name in register_use:
						#self.put_debug('Freeing up %s (%s)' % (a_id, reg_name))
						
						#assignment['register'] = None
						register_use[reg_name] = False
				
			
			line = self.get_next_line()
			line_i = self.line_num
			if line is None: break
			if line == '': continue
			if line == '}': break
			
			
			# Check which registers are used for the first time
			for a_id, assignment in assignments.items():
				if (assignment['register'] is None) and (assignment['first_write'] == line_i):
					#self.put_debug('Need to allocate a register for writing to %s' % a_id)
					
					found = False
					for reg_name, reg_used in register_use.items():
						if not reg_used:
							register_use[reg_name] = True
							assignment['register'] = reg_name
							#self.put_debug('Allocated register %s for storing %s' % (reg_name, a_id))
							found = True
							break
					if not found:
						raise Exception('Ran out of free registers!')
			
			self.put_debug('parse_block:	%d	%s' % (self.line_num, line))
			# Show commented LLVM IR in S file
			#self.emit('; %d	%s' % (self.line_num, line))
			
			
			words = line.split(' ')
			
			if words[0][-1:] == ':':
				#self.put_debug('Label')
				label_name = words[0][:-1]
				loop_comment = '' if not label_name in loop_labels else '	; Start of loop'
				self.emit('_%s_%s:%s' % (def_name, label_name, loop_comment))
				
				#@FIXME: If jumping backwards (loop) register use must be restored!
				#@TODO: So: Freeze registers
				self.put('@TODO: Must store/restore the register usage')
				
			elif (len(words) > 2) and (words[1] == '='):
				#self.put('Assignment')
				dst_name = words[0]
				dst_reg = assignments[dst_name]['register']
				
				# Ignore "alloca" for now
				if words[2] == 'alloca':
					#@TODO: Actually reserve some memory on heap
					continue
				
				elif words[2] == 'load':
					addr_name = words[5].replace(',', '')
					
					#dst_i = a_ids.index(dst_name)
					#addr_i = a_ids.index(addr_name)
					#self.emit('	loadw %d(sp), r0' % ((addr_i - params_count) * 2))
					#self.emit('	storw r0, %d(sp)' % ((dst_i - params_count) * 2))
					addr_reg = assignments[addr_name]['register']
					if (type(addr_reg) is int):
						if (type(dst_reg) is int):
							# from mem to mem
							self.emit('	loadw %d(sp), %s' % (addr_reg, 'r0'))
							self.emit('	storw %s, %d(sp)' % ('r0', dst_reg))
						else:
							# from mem to reg
							self.emit('	loadw %d(sp), %s' % (addr_reg, dst_reg))
					else:
						if (type(dst_reg) is int):
							# from reg to mem
							self.emit('	loadw %s, %s' % (addr_reg, 'r0'))
							self.emit('	storw %s, %d(sp)' % ('r0', dst_reg))
						else:
							# from reg to reg
							self.emit('	loadw %s, %s' % (addr_reg, dst_reg))
					
				elif words[2] == 'icmp':
					a1_name = words[5].replace(',', '')
					a2_name = words[6].replace(',', '')
					
					#@TODO: compare against immediate!
					a1_reg = assignments[a1_name]['register']
					if a2_name in assignments:
						a2_reg = assignments[a2_name]['register']
						self.emit('	movw %s, %s' % (a1_reg, dst_reg))
						self.emit('	cmpw %s, %s' % (a2_reg, dst_reg))
					else:
						# a2 is immediate
						self.emit('	movw %s, %s' % (a1_reg, dst_reg))
						self.emit('	cmpw $%s, %s' % (a2_name, dst_reg))
					
				elif words[2] in ['mul', 'add']:
					a1_name = words[5].replace(',', '')
					a2_name = words[6].replace(',', '')
					#@TODO: compare against immediate!
					a1_reg = assignments[a1_name]['register']
					self.emit('	movw %s, %s' % (a1_reg, dst_reg))
					
					# Translate op
					op = '%sw' % words[2]	# mul, add -> mulw, addw
					
					if a2_name in a_ids:
						a2_reg = assignments[a2_name]['register']
						self.emit('	%s %s, %s' % (op, a2_reg, dst_reg))
					else:
						self.emit('	%s $%s, %s' % (op, a2_name, dst_reg))
					
				else:
					raise Exception('UNSUPPORTED, YET: %s' % line)
			
			elif words[0] == 'store':
				src_name = words[2].replace(',', '')
				dst_name = words[4].replace(',', '')
				
				dst_reg = assignments[dst_name]['register']
				if (not src_name in a_ids):
					# Immediate!
					imm = int(src_name)
					
					if (type(dst_reg) is int):
						# from imm to mem
						self.emit('	storw $%d, %d(sp)' % (imm, dst_reg))
					else:
						# from imm to reg
						self.emit('	movw $%d, %s' % (imm, dst_reg))
				else:
					# from assign...
					src_reg = assignments[src_name]['register']
					
					if (type(src_reg) is int):
						if (type(dst_reg) is int):
							# from mem to mem
							self.emit('	loadw %d(sp), %s' % (src_reg, 'r0'))
							self.emit('	storw %s, %d(sp)' % ('r0', dst_reg))
						else:
							# from mem to reg
							self.emit('	loadw %d(sp), %s' % (src_reg, dst_reg))
					else:
						if (type(dst_reg) is int):
							# from reg to mem
							self.emit('	storw %s, %d(sp)' % (src_reg, dst_reg))
						else:
							# from reg to reg
							self.emit('	movw %s, %s' % (src_reg, dst_reg))
					
			
			elif words[0] == 'br':
				if words[1] == 'label':
					label_name = words[2].replace('%','')
					
					if labels[label_name] == line_i+2:	# clang inserts one new-line before labels
						self.put_debug('Optimizer: Omitting branch to next line')
						#self.emit('	; Optimizer omitted branch to next line')
					else:
						loop_comment = '' if not label_name in loop_labels else '	; Jump back to loop'
						self.emit('	br	_%s_%s%s' % (def_name, label_name, loop_comment))
					
				elif words[1] == 'i1':
					cmp_name = words[2].replace(',', '')
					cmp_reg = assignments[cmp_name]['register']
					
					if_name = words[4].replace('%','').replace(',', '')
					else_name = words[6].replace('%','').replace(',', '')
					
					#self.put_debug('line_i=%d, if=%d, else=%d' % (line_i, labels[if_name], labels[else_name]))
					
					# If...
					if labels[if_name] == line_i+2:	# clang inserts one new-line before labels
						self.put_debug('Optimizer: Switching order to omit branch to next line (else-label)')
						loop_comment = '' if not else_name in loop_labels else '	; Jump back to loop'
						self.emit('	bne1b	%s, _%s_%s%s' % (cmp_reg, def_name,else_name, loop_comment))
						#self.emit('	; Optimizer omitted branch to if-case and negated the comparison')
					else:
						loop_comment = '' if not if_name in loop_labels else '	; Jump back to loop'
						self.emit('	beq1b	%s, _%s_%s%s' % (cmp_reg, def_name,if_name, loop_comment))
						if labels[else_name] == line_i+2:	# clang inserts one new-line before labels
							self.put_debug('Optimizer: Omitting branch to next line (else-label)')
							#self.emit('	; Optimizer omitted branch to else-case in next line')
						else:
							# Else...
							loop_comment = '' if not else_name in loop_labels else '	; Jump back to loop'
							self.emit('	br	_%s_%s%s' % (def_name, else_name, loop_comment))
					
				else:
					raise Exception('Unknown branching condition in "%s"' % line)
				
			elif words[0] == 'call':
				
				rest_text = ' '.join(words[2:])
				call_name = rest_text[:rest_text.index('(')].replace('@', '')
				args_text = rest_text[rest_text.index('(')+1:rest_text.rindex(')')]
				
				self.put('@TODO: Clean up (push/shuffle) registers to make space for args and return value')
				self.put('@TODO: Make sure the arguments are in their designated argument registers')
				self.emit('	;@TODO: CALL NOT IMPLEMENTED: %s' % line)
				self.emit('	bal	(ra,era), _%s' % call_name)
				
			
			elif words[0] == 'ret':
				
				if words[1] != 'void':
					
					#@TODO: Make sure to set a return value!
					v_name = words[2]
					if v_name in a_ids:
						v_reg = assignments[v_name]['register']
						self.emit('	movw	%s, r0	; Return value' % v_reg)
					else:
						self.emit('	movw	$%s, r0	; Return value' % v_name)
				
				# Fix stack
				#self.emit('	subw	$-%d,sp' % ((len(assignments) - params_count)*2))
				self.emit('	subw	$-%d,sp' % heap_size)
				self.emit('	jump	(ra,era)')
			else:
				self.put('Unhandled: %s' % line)
				self.emit('	; Unhandled line: %s' % line)
		
		# Emit function epilogue
		self.emit('; End of function "%s"\n\n' % def_name)


if __name__ == '__main__':
	filename = 'foo.c'
	
	cc = CR16B_LLVM_IR_Compiler()
	cc.compile(filename)
	
